## Modern Operating System
---

#### Chapter2
- 进程Process
    - 正在运行的程序的抽象，包括程序计数器、寄存器和当前变量值
    - (程序是食谱，进程是烹饪的过程)
    - **前台进程+守护进程daemon**
    - fork以后父子进程拥有相同的内存映像、环境变量和打开的文件描述符
        - fork后execve前，子进程可以对stdin/stdout/stderr进行重定向
    - Unix系统进程间是继承关系，所有进程都属于以init进程为根的一棵树；Windows系统中所有进程的地位都是相同的
    - 状态：就绪态，运行态，阻塞态
    - 进程表(即进程控制块)保存进程重要的状态信息，如程序计数器、堆栈指针、内存分配状况，文件描述符、调度信息等
- 线程Thread
    - 原因
        - 适合CPU密集型和IO密集型混合的场景
        - 相比进程，创建和销毁的开销较小
        - 应用可以并发/并行执行，充分利用计算机资源
    - 服务器模型
        - 多线程，并行+阻塞系统调用
        - 单进程单线程，无并行+阻塞系统调用
        - 有限状态机(事件模型)，并行+非阻塞系统调用+中断(信号)
    - **线程独有**
        - 程序计数器，记录程序的指令位置
        - 寄存器，保存当前的工作变量
        - 堆栈，记录执行的历史，已经执行还未返回的过程调用
    - 用户级线程，线程切换只需要少量的机器指令，由线程调度程序完成调度
    - 内核级线程，线程切换需要完整的上下文切换，修改内存映像，使高速缓存失效
- 进程 = 资源集合 + 执行
    - 地址空间中存放程序、数据、打开的文件、子进程、定时器、信号处理程序等**线程共享**
    - 执行实体是线程，由CPU完成调度
- 临界区
    - 对共享内存进行访问的**程序片段**称为临界区域
- 自旋锁
    - 处于**忙等待**的锁，即不停地检测变量值或资源是否可用
    - 忙等待浪费了CPU时间，只有在有理由认为等待的时间**非常短**的情况下才使用忙等待
- TSL指令
    - test and set lock
    - 硬件指令，CPU执行TSL指令锁住内存总线，禁止其他CPU在本指令结束前访问内存
    - **屏蔽中断**的方式不能阻止其他CPU在TSL指令执行中间访问内存，无法应对多核的硬件架构
- XCHG
    - Intel x86 CPU指令，替代TSL指令
    - **原子性**地交换内存或寄存器的值
- 用户区互斥锁
    - 资源竞争小，等待时间短，用户空间层的自旋锁速度很快
    - 竞争大，等待时间长，应该阻塞进程/线程，在资源可用后重新运行
    - (系统调用)阻塞引起内核不停地切换，导致性能开销很大(相对地)
- *<u>管程</u>是编程语言概念，C/CPP和其他语言都没有管程；管程的应用需要编译器的支持，由编译器识别和管理*
- *<u>屏障Barrier</u>应用于进程组，当所有的进程到达屏障后才会进入下一个执行阶段*
- 进程切换(上下文切换)
    - 用户态 <-> 内核态
    - 保存进程状态，在进程表中保存寄存器值
    - 保存内存映像(页表访问状态)
    - 调度算法选择新的进程
    - 装载新的内存映像到MMU
    - 内存高速缓存也会失效，缓存从内存中动态装入2次
- **调度**
    - CPU密集型应用/进程
    - IO密集型应用/进程
    - 非抢占式系统/算法
    - 抢占式系统/算法
    - 通用系统
        - 公平，给每个进程公平的CPU份额
        - 平衡，系统的所有部分都忙碌
        - 强制策略，保证规定的策略被执行
    - 批处理系统
        - 吞吐量
        - 周转时间，从提交到完成的统计平均时间
        - CPU利用率
    - 交互式系统
        - 响应时间
        - 均衡性，与用户期望的需求一致
    - 实时系统
        - 满足**截止时间**要求
    - 算法
        - 非抢占式的**先入先出**
        - 非抢占式的**最短作业优先**
        - 轮转调度算法(round robin)
        - 优先级调度算法
        - 多级队列
            - 进程按照优先级分为多个组，进程组内部采用轮转调度，进程组之间采用优先级调度
            - 降低已运行进程的优先级，同时增加它的时间片，即最高优先级获得1个时间片，次高优先级获得2个时间片，再次一级获得4个时间片
        - 最短进程优先(老化)，即根据进程过去运行的时间进行推测，然后执行估计运行时间最短的那一个
    - 机制与策略分离
        - 调度机制位于内核，调度策略(算法)以某种形式参数化，由用户进程控制，从而使系统的调度更加灵活高效
- *进程、线程和调度不再是研究的热点，功耗、虚拟化、云计算和安全问题成为新的热点主题*

#### Chapter3
- 寄存器 1ns <1KB
- 高速缓存 2ns 4MB
    - 命中通常需要2个时钟周期
    - 对L1缓存的访问不存在延时
    - 对L2缓存的访问存在1～2个时钟周期
- 主存 10ns 1~8GB
    - Random Access Memory
    - Read Only Memory
    - EEPROM
    - Flash
- 磁盘 10ms 1~4TB
    - 机械装置
    - 磁头在磁盘上移动
- 上下文切换
    - 多道程序系统中，从一个程序切换到另一个程序的过程
    - 来自缓存的所有修改写回磁盘，并修改MMU中的映射寄存器，两种操作的代价很高
- 绝大多数的设备驱动程序在内核态运行，很少一部分系统如MINIX3在用户态运行所有的驱动程序
    - CPU在内核态和用户态切换
    - CPU触发中断，寻找中断处理程序的地址，运行中断处理程序，然后返回用户程序
- 操作系统
    - 为用户提供**抽象**和管理计算机资源
    - 系统调用会陷入内核，操作系统执行TRAP指令由用户态切换到内核态
    - 系统调用可能会阻塞调用者，同时操作系统会执行其他进程(任务)
    - 若不通过系统调用执行一个“过程”，即无须陷入内核，它通常会在用户空间完成，性能得到很大地提高


#### Chapter3
- 分层存储体系
    - 操作系统对存储器创建抽象模型并进行管理
    - 高速缓存 - 内存 - 磁盘/移动存储装置
    - 操作系统中的存储管理器部件负责内存管理
- 在没有存储器抽象的情况下运行多个程序
    - 操作系统交换内存中的数据(全部)**交换技术**
    - 程序同时装载到内存的不同位置
        - 程序引用了内存的物理地址
        - **静态重定位**技术避免程序引用相同的地址
- 地址空间
    - 进程可以用于寻址内存的一套地址集合
    - 多个进程在内存中同时存在而不会互相影响
        - **保护**
        - **重定位**
- 处理内存超载的通用方法
    - 交换技术
        - 运行时装载至内存，空闲时交换至磁盘
        - 程序换入换出的开销，内存管理的代价
        - 位图管理空闲内存(分配单元大小、位图大小、位图的连续查找和管理)
        - 链表管理空闲内存(双向链表比单向链表更方便)
            - 首次适配算法
            - 下次适配算法(从上次适配点开始，而非链表头)
            - 最佳适配算法(会产生大量无用的小空闲区，即内存碎片)
            - 快速适配算法(为常用大小的空闲区维护单独的链表)
            - 进程和空闲内存使用独立的链表进行管理+排序
            - **单独使用链表管理空闲内存，当进程终止/换出释放内存时，查找并合并相邻内存块的操作是非常耗时的**
    - 虚拟内存
        - 程序的地址空间被分割成多个页面，每一页有连续的地址范围；页被映射到物理内存，在需要的时候装载到内存中运行
        - 创造的地址空间概念，对物理内存的抽象
    - 虚拟地址
        - 由程序产生到地址，共同构成了一个虚拟地址空间
        - 虚拟页号+字节偏移量
    - 物理地址
        - 页框号+字节偏移量
    - 页表
        - 虚拟地址 -> 物理地址
        - 虚拟内存分解成页，每一页映射到物理内存的页框，或者解除映射
        - 每个进程都有自己的页表
- 分页的实现
    - **虚拟地址到物理地址的映射必须很快**
    - **虚拟地址很大时，页表也会很大**
    - TLB - translation lookaside buffer
        - 快表/页表转换缓冲区
        - 硬件TLB由MMU实现
        - 软件TLB由操作系统实现
    - 软失效 - 页面在内存中而不在TLB中，比如不在进程的页表中称为“次要缺页错误”
    - 硬失效 - 页面不在内存中，触发“缺页中断”
    - 段错误 - 访问非法地址，操作系统终止进程
    - 多级页表
        - 避免载入进程的全部页表，如只需要代码段、数据段和堆栈段
        - 32位虚拟地址空间4GB大小
        - 4KB页面大小，有1024*1024个页面(约1million)
        - PT1+PT2+offset，如0x00403004=1+3+4，即二级页表
    - 倒排页表
        - 物理内存的页框对应于一个页表项，而不是虚拟页面对应一个页表项
        - 节省了大量空间，但虚拟地址到物理地址的转换变得很困难
        - TLB记录频繁访问的页面，TLB失效时利用“散列表”结构快速搜索倒排页表查找页框号
        - (以虚拟地址散列，在内存中具有相同散列值的虚拟页面链接在一起)
- 页面置换算法
    - 最优页面置换算法
        - 仅存在于理论设计
        - 可以作为其他算法的评价标准
    - 最近未使用算法
        - 时钟中断定期刷新被访问的页面，发生缺页中断时优先置换未使用的页面
    - 先进先出算法
        - first in first out
    - 第二次机会算法
        - 先入先出+访问标志
        - 按照先入先出的顺序，如果标志无效，直接置换；如果标志有效，将标志置为无效后重新添加到队列的尾部
    - 时钟算法
        - 第二次机会算法的变种，队列是**环形链表**
        - 容量固定时使用环形链表是一种很好的选择
        - 链表的移动和操作是很<u>耗时</u>的
    - 最近最少使用页面算法
        - “最优算法”的近似，不易实现
    - **最不常用算法(老化算法)**
        - 时钟中断时操作系统将页面的R位(0/1)加到页面的计数器上，缺页中断时置换计数值最小的页面
        - 改进(**位运算**)：先将计数器右移一位，然后将R位(0/1)加到计数器的最高位
    - (CPU执行一条指令是纳秒级，缺页中断时置换页面是毫秒级，频繁发生缺页中断会影响程序的运行效率)
    - 工作集算法
        - 进程运行前预先装入工作集页面(而不是一个页一个页地装载)，大大减少缺页中断率
        - 最近k次内存访问所使用过的页面集合(维护k位寄存器的开销很大，实际中没有使用)
        - 近似处理：在过去t时间内存访问所用到的页面集合
    - **工作集时钟算法**
        - 工作集算法+时钟算法
        - 实现简单，性能较好，广泛应用
- 通常情况下，全局分配策略优于局部分配策略
    - 发生缺页中断时，选择替换整个内存中的页面，还是选择替换对应进程的页面
- 页面大小
    - 太大，容易产生内存碎片，内存利用率较低
    - 太小，内存利用率更高，但需要更多的页面和更大的页表，内存与磁盘的传输时间更长
    - 考虑内存碎片和页表大小的前提下，最优页面大小是4KB，实际应用中也会使用8KB等其他页面大小
- 分离的指令空间和数据空间
    - 指令和数据不在同一个地址空间内，地址空间都是从0到某个最大值
- 共享页面
    - 页表和进程表的数据结构无关，每个进程的进程表中有2个指针，一个指向指令空间地址，另一个指向数据空间地址
    - **写时复制**
- 共享库
    - 静态库和目标文件一起链接生成可执行程序
    - 共态库链接时，链接器没有加载被调用的函数，而是加载一小段在运行时绑定被调用函数的stub routine
    - 运行时，共享库和程序一起装载，或者在其包含的函数第一次被调用时装载
    - 共享库不是一次性地装载入内存，而是以页面为单位装载的
    - 库没有共享时，可以采用**装载时重定位**的方式跳转到指令的地址
    - **地址无关代码机制**使用特殊的编译选项告知编译器编译共享库时不要产生绝对地址的指令，而是产生使用相对地址的指令(相对共享库)
- 内存映射文件
    - 磁盘文件当作内存的后备存储
    - 文件映射到进程中虚拟地址的一部分，访问页面时才读入，进程退出或显示解除映射后改动的页面会被写回到磁盘文件中
    - 两个进程同时映射了同一个文件，它们可以通过“共享内存”进行通信
- **3.6.2缺页中断的执行过程**
- 磁盘交换区
    - Unix系统划分一块独立的磁盘用作页面交换区，在分区里没有普通的文件系统
    - 交换区的磁盘地址即进程映像所保存的位置，记录在进程表里的
- 分段
    - 为了使**程序**和**数据**可以被划分为逻辑上独立的地址空间并且有助于**共享和保护**
    - 每个段由一个从0到Max的线性地址序列构成，段是一个逻辑实体，一般不会包含不同类型的内容
- 分段+分页
    - 程序分段后，在段中同时采用分页的机制
    - x86虚拟地址的两张表LDT-local descriptor table和GDT-global descriptor table，即局部描述符表和全局描述符表
    - *x86-64不再支持分段机制，Unix和Windows都不曾使用这种存储模型*
    - 不允许分页，即纯分段方式，线性地址被解释为物理地址然后被送往存储器
    - 允许分页，线性地址被解释为虚拟地址并通过页表映射成物理地址
        - 32位虚拟地址，4KB页大小(偏移量12位)，1个段有多达100万个页面(20位，1024*1024)
        - 2级映射，10位页目录+10位页面+12位偏移量
        - 先在页目录中找到指向页表的指针(32位)，然后在页表中找到页框的物理地址(32位中的20位，其他位是访问位、脏位、保护位等)，最后加上偏移量(12位)得到物理地址
        - **1024个4KB页框的页表可以处理4MB的内存，小于4MB的段目录中只有1个表项，该表项指向唯一的页表，从而将段的页面开销从100万个减少到了2个**

#### Chapter3
- 资源
    - 可抢占资源
        - 如内存，CPU
        - 可以在进程之间重新分配资源避免发生死锁
    - 不可抢占资源
        - 如光盘刻录机
    - 抽象的资源事件顺序，请求资源 -> 使用资源 -> 释放资源
    - 资源允许有**多个实例**，资源实例之间是相互独立的
- 资源死锁
    - 规范定义：*进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件*
    - 即，**进程因为等待另一个进程引发的事件而阻塞，陷入无限等待的状态**
    - 死锁的条件(必要条件)
        - **互斥**，资源要么可用，要么已分配
        - **不可抢占**，已分配的资源只能由持有者释放，不能强制性地被抢占
        - **已分配资源的进程再请求新的资源**
        - **环路等待**，死锁发生时至少有2个进程构成资源请求环路
- 死锁检测
- 死锁恢复
    - 利用抢占恢复，将资源强制转移给另一个进程，实现的难度很大
    - 利用回滚恢复，将进程回滚到更早的检查点，那时进程没有获得所需的资源
    - 利用杀死进程恢复
        - 选择的进程持有死锁进程环中需要的资源
        - 选择的进程重新运行不要带来副作用
- 死锁避免
    - 银行家算法
        - 检查每一个请求是否能达到安全状态，若能，则满足请求；若不能，则推迟请求
        - 安全状态下可用的资源能满足进程的要求，在进程运行后释放并回收资源，使得下一个请求仍然是安全的
    - 银行家算法的**不足**
        - 有意义(作为一种启发式方法)但缺乏实用价值
        - 进程很难在运行前预测其需要的最大资源数
        - 进程数不是固定的，往往在不断地变化
        - 可用资源也不是固定的，可能会由于故障变得不可用
- 死锁预防
    - 破坏“互斥”条件，*进程不会直接持有资源*
    - 破坏“再次请求新资源”条件，*一次性请求所有的资源*
    - 破坏“不可抢占”条件，*强制性地抢占资源*
    - **破坏“环路等待”条件**
        - 其一，*进程请求其他资源前，先释放当前所持有的资源*
        - 其二，**对资源按序编号，不允许进程请求比当前所占有资源编号低的资源**
- 两阶段加锁(见于数据库系统中)
    - 第一阶段进程对所需的记录进行加锁，若记录已被加锁，则释放当前持有的所有锁
    - 第二阶段完成更新(业务)并释放锁
    - *实时系统或进程管理系统中，因缺少资源就中断进程然后重新运行，可能导致很严重的错误，通常不会采用*

#### Chapter4
- 进程是对处理器的抽象，进程虚拟地址空间是对物理内存的抽象
- 文件是对磁盘的抽象，它是进程创建的**信息逻辑单元**
- 目录
    - 很多系统中，目录就是文件
    - 提供查找文件所需要的信息，包括文件名和i节点号(内含文件属性)
- 链接
    - 硬链接
        - 建立链接会增加文件的i节点计数，但不会改变文件的所有者
        - 删除链接会减少文件的i节点计数
        - 若文件的所有者删除文件，只有当i节点计数值为0时才会真正删除文件，否则只会删除所有者的目录项信息
    - 符号链接，只包含所链接文件的路径名
- i节点(index-node) -> 磁盘块
    - 记录文件属性和文件块磁盘地址的数据结构，通过它可以找到文件的所有块
    - 只有文件打开时，i节点才在内存中
    - 每个i节点只能存储固定数目的磁盘地址
- Unix移除文件
    - 在目录中删除文件
    - 释放i节点到空闲节点池
    - 将所有磁盘块归还到空闲磁盘块池
- **幂等**
    - 操作可以重复执行多次，不会引起错误，不会产生不一致的结果
    - 日志文件系统的数据结构和写入操作是幂等的，那么崩溃恢复就可以被快速安全地实施
- 虚拟文件系统
    - 将多种文件系统统一成一个有序的结构
    - 用户进程 - 虚拟文件系统 - 文件系统(ext2, ext3, CD-ROM)
    - 实际文件系统**装载**(注册)后，虚拟文件系统才可以使用它
    - 通过<u>进程表</u>和<u>文件描述符</u>确定<u>v节点</u>的位置，跟随指针指向<u>函数表</u>，调用<u>函数</u>运行在实际文件系统中的代码得到请求的数据块
- 文件描述符
    - 指向v节点指针的数据结构
- v节点
    - 描述文件，包含文件的i节点信息和指向v节点操作的函数表的指针
- 文件系统的一致性
    - 在修改写回磁盘块前系统崩溃，文件系统有可能处于不一致的状态，特别是未写回i节点块、目录块、包含空闲列表的块
    - Unix fsck程序检验文件系统的一致性
        - 通过计数器跟踪目录项、i节点、空闲表信息比较磁盘块/文件的一致性
- 文件系统访问的优化措施
    - 高速缓存
        - 散列表
        - FIFO、LRU
    - 块提前读
        - 只适用于顺序读取的文件
    - 减少磁盘臂运动
        - 顺序访问的数据块放在同一个磁盘柱面上，减少磁盘的寻道时间和旋转时间
        - 磁盘分成多个柱面组，每个柱面组有自己的i节点、数据块、空闲表，减少它们之间的寻道时间
- 相对路径
    - .是当前目录的i节点号
    - ..是父目录的i节点号
    - 目录创建的时候会自动创建

#### Chapter8
- 《分布式系统》《Distributed System》
- 硬件 - 操作系统 - **中间件** - 应用
- 基于文档的中间件**使分布式系统看起来像一个巨大的超链接集合**
    - Web Page - Document
    - *文档*可以包含文本、图像、声音、视频、超链接等
    - URL，protocol://DNS-name/file-name
- 基于对象的中间件
    - 对象 + 方法
    - ORB，object request broker
    - *每个CORBA对象只存在于一个服务器上，CORBA只在小规模系统中才能有效地工作*
- 基于协作的中间件
    - coordination-based middleware
    - Linda
        - 相互独立的进程通过**元组空间**进行通信
        - 与对象不同，**元组**是数据
        - out和in操作是原子性的
        - in操作的匹配，即模版与元组空间中每个元组的同一域相比较
    - 发布/订阅模式
- 基于文件系统的中间件
    - 上传/下载模式，文件的读写操作在本机完成，传输时一次性传送整个文件到服务器
    - 远程访问模式，文件的读写操作在服务器完成，只传送小块的文件到服务器
    - 顺序一致性，系统强调所有的系统调用有序，并且所有的处理器看到的都是相同的顺序
    - 会话语义，在一个打开文件上进行的修改仅对修改的进程可见，只有当文件关闭后才对其他的进程可见
        - 会话关闭后，进程所作的修改才会同步至服务器
        - 多个会话同时修改一个文件时，最终的结果取决于服务器的策略(选择最后一个关闭的会话，还是随机选择一个会话)
