## High Performance MySQL
---

#### Explain
- 使用方法
    - EXPLAIN + SELECT + \G
    - 近似结果，当作优化的参考
    - 涉及子查询时，MySQL会执行子查询将结果放在临时表中，然后完成外层查询优化
    - *(MySQL5.6允许匿名临时表尽可能晚的具体化，而不是在每次优化和执行此临时表部分时再创建使用；
        因此，新版EXPLAIN带子查询的查询语句并不需要先执行子查询)*
- EXPLAIN PARTITION
    - 显示查询访问的分区
- EXPLAIN EXTENDED
    - “逆向编译”执行计划为SELECT语句
- id
    - 值越大，执行优先级越高
    - 值相同，按照顺序执行
- select_type
    - **SIMPLE** - 不包含子查询和UNION
    - **SUBQUERY** - 在SELECT列表中的子查询
    - **DERIVED** - FROM子句中的子查询，子查询的结果放在临时表中
    - **UNION** - UNION之后的SELECT被标记为UNION
    - **UNION RESULT** - 标记UNION匿名临时表中的SELECT结果
    - **DEPENDENT** - SELECT依赖于外层查询的数据
- table
    - 查询计划总是选择**左侧深度优先树**
    - FROM film INNER JOIN film_actor INNER JOIN actor ==> actor,film_actor,film
- type
    - **ALL** - 全表扫描
    - **index** - 按照<u>索引次序</u>而非行扫描全表，相比ALL全表扫描的开销小
        - 若是<u>随机访问</u>，开销会比较大
        - 若Extra=“Using index”，表示使用**覆盖索引**
    - **range** - 范围的索引扫描，如BETWEEN或WHERE+>，开销与index相当
    - **ref** - 索引查找，与值作比较
        - 返回所有匹配值的行，即会找到多个符合条件的行
        - 非唯一索引，或唯一索引的非唯一前缀
    - **eq_ref**
        - 最多只返回一条符合条件的记录
        - 主键，或唯一索引
    - **const,system**
        - MySQL优化将查询条件转换为常量
    - **NULL**
        - MySQL在优化阶段分解查询语句，执行阶段可以不用再访问表就得到结果
- key_len
    - 单位是byte，显示索引字段可能的最大长度，不是实际使用的长度
    - MySQL在**utf8**字符集下，每个字符最多为**3字节**长
- **Extra**
    - Using index - 使用覆盖索引，避免访问表
    - Using where - 存储引擎检索后再进行过滤
    - Using temporary - 使用临时表对查询结果排序
    - Using filesort - 对结果使用文件排序，在内存或磁盘上完成
    - *Range checked for each record* - 没有好用的索引，联接时重新评估

#### 大文件传输
- 根据场景选用
    - 网络带宽足够，直接传输未压缩的文件，节约CPU资源
    - 带宽不够，文件压缩后再传输(多数情况都会选择压缩文件)
- 相比**gzip**，**bzip2**的压缩率更高，时间却更长；**LZO**的压缩速度更快，压缩率却更低
- gzip -> scp -> gunzip
    - 多数时候选用的传输方式，每一步都需要读写磁盘
    - 串行操作，效率不高
- SSH内建的压缩特性
    - gzip -c File1 | ssh user@host gunzip -c - > File2
    - **管道直接读取-传输-写入文件**
- 非加密的传输方法
    - (S)nc -l -p 1234 | gunzip -c - > FILE2
    - (C)gzip -c - FILE1 | nc -q l host 1234
    - (tar压缩方式能保留文件名、文件权限和文件时间)
    - (S)nc -l -p 1234 | tar xvfz -
    - (C)tar cvfz - FILE1 | nc -q l host 1234
- rsync
    - 易于传输镜像文件
    - 支持断点续传
- 基准测试的结果发现rsync < scp < ssh < nc
    - 仅作参考
- **md5sum**
    - 校验文件的完整性
    - 完整扫描的代价比较高，压缩算法本身会做至少一次CRC检验

#### Chapter1
- **事务**
    - 一组原子性的SQL查询，即一个独立的工作单元，**由存储引擎实现，不在数据库服务层**
    - 要么全成功，要么全失败
    - **特性**
        - 原子性
        - 一致性 - *状态转换后保持一致*
        - 隔离性
        - 持久性
    - (需要数据库系统做更多的工作，增加了系统的开销)
    - **隔离级别**
        - 未提交读 - **脏读**，未提交的事务对其他事务是可见的
        - 提交读 - 未提交的事务对其他事务是不可见的
            - 不可重复读，同一事务中执行相同的查询可能得到不同的结果
        - 可重复读(MySQL默认隔离级别)
            - **幻读**，事务前后两次读取范围记录时，会产生幻行，读取间隔另一个事务在该范围内插入了新纪录
            - 多版本并发控制可以解决幻读问题
        - 串行化 - 每一行数据加锁，导致大量的超时和锁争用问题
    - InnoDB可以在事务执行过程中的任何时候加锁，只能在COMMIT或ROLLBACK时才会释放所有的锁
        - *LOCK TABLES/UNLOCK TABLES*在服务器层实现
    - 死锁
        - 死锁检测和死锁超时机制
        - InnoDB，将持有最少行级排他锁的事务回滚(比较简单的**死锁回滚算法**)
        - 事务型系统只有部分或完全*回滚*其中一个事务，才能打破死锁，然后重新执行回滚的事务
    - 事务型存储引擎
        - InnoDB
        - NDB Cluster
- **多版本并发控制**
    - 基于提升并发性能的目标，事务型引擎不是简单地使用行级锁，同时实现了多版本并发控制机制
    - InnoDB-MVCC
        - 每行记录保存2个隐藏的列(空间->时间)，1列保存行记录的创建时间，1列保存行记录的删除时间
        - (“创建时间”、“删除时间”可能不是实际的时间，而是系统版本号作为事务的版本号)
        - 插入，当前系统版本号作为创建时间
        - 删除，当前系统版本号作为删除时间
        - 更新，插入一条新纪录，当前系统版本号作为新行的创建时间，当前系统版本号作为原行的删除时间
        - **查询**，事务的版本号大于或等于行记录的创建版本，小于行的删除版本(或行的删除版本未定义)
    - 只在**提交读**和**可重复读**两个隔离级别下工作，使得大多数读操作都不需要加锁，并且保证读取到符合标准的记录行
- InnoDB
    - 事务型(Commit, Rollback)
    - 自动崩溃恢复
    - 支持数据和索引放在单独的文件中
    - MVCC支持高并发
    - 默认隔离级别-可重复读
    - 间隙锁消除幻行的影响
    - 基于聚簇索引建立，主键查询的性能很高
- MyISAM
    - 不支持事务和行级锁(使用**表锁**)
    - 不支持崩溃后安全恢复
    - 支持全文索引
    - 支持表压缩(对于*只读*的数据进行压缩，可以减少磁盘空间和*磁盘IO*)
