## High Performance MySQL
---

#### Explain
- 使用方法
    - EXPLAIN + SELECT + \G
    - 近似结果，当作优化的参考
    - 涉及子查询时，MySQL会执行子查询将结果放在临时表中，然后完成外层查询优化
    - *(MySQL5.6允许匿名临时表尽可能晚的具体化，而不是在每次优化和执行此临时表部分时再创建使用；
        因此，新版EXPLAIN带子查询的查询语句并不需要先执行子查询)*
- EXPLAIN PARTITION
    - 显示查询访问的分区
- EXPLAIN EXTENDED
    - “逆向编译”执行计划为SELECT语句
- id
    - 值越大，执行优先级越高
    - 值相同，按照顺序执行
- select_type
    - **SIMPLE** - 不包含子查询和UNION
    - **SUBQUERY** - 在SELECT列表中的子查询
    - **DERIVED** - FROM子句中的子查询，子查询的结果放在临时表中
    - **UNION** - UNION之后的SELECT被标记为UNION
    - **UNION RESULT** - 标记UNION匿名临时表中的SELECT结果
    - **DEPENDENT** - SELECT依赖于外层查询的数据
- table
    - 查询计划总是选择**左侧深度优先树**
    - FROM film INNER JOIN film_actor INNER JOIN actor ==> actor,film_actor,film
- type
    - **ALL** - 全表扫描
    - **index** - 按照<u>索引次序</u>而非行扫描全表，相比ALL全表扫描的开销小
        - 若是<u>随机访问</u>，开销会比较大
        - 若Extra=“Using index”，表示使用**覆盖索引**
    - **range** - 范围的索引扫描，如BETWEEN或WHERE+>，开销与index相当
    - **ref** - 索引查找，与值作比较
        - 返回所有匹配值的行，即会找到多个符合条件的行
        - 非唯一索引，或唯一索引的非唯一前缀
    - **eq_ref**
        - 最多只返回一条符合条件的记录
        - 主键，或唯一索引
    - **const,system**
        - MySQL优化将查询条件转换为常量
    - **NULL**
        - MySQL在优化阶段分解查询语句，执行阶段可以不用再访问表就得到结果
- key_len
    - 单位是byte，显示索引字段可能的最大长度，不是实际使用的长度
    - MySQL在**utf8**字符集下，每个字符最多为**3字节**长
- **Extra**
    - Using index - 使用覆盖索引，避免访问表，数据就在索引中
    - Using where - 存储引擎查找后再进行过滤
    - Using temporary - 使用临时表对查询结果排序
    - Using filesort - 对结果使用文件排序，在内存或磁盘上完成
    - *Range checked for each record* - 没有好用的索引，联接时重新评估

#### 大文件传输
- 根据场景选用
    - 网络带宽足够，直接传输未压缩的文件，节约CPU资源
    - 带宽不够，文件压缩后再传输(多数情况都会选择压缩文件)
- 相比**gzip**，**bzip2**的压缩率更高，时间却更长；**LZO**的压缩速度更快，压缩率却更低
- gzip -> scp -> gunzip
    - 多数时候选用的传输方式，每一步都需要读写磁盘
    - 串行操作，效率不高
- SSH内建的压缩特性
    - gzip -c File1 | ssh user@host gunzip -c - > File2
    - **管道直接读取-传输-写入文件**
- 非加密的传输方法
    - (S)nc -l -p 1234 | gunzip -c - > FILE2
    - (C)gzip -c - FILE1 | nc -q l host 1234
    - (tar压缩方式能保留文件名、文件权限和文件时间)
    - (S)nc -l -p 1234 | tar xvfz -
    - (C)tar cvfz - FILE1 | nc -q l host 1234
- rsync
    - 易于传输镜像文件
    - 支持断点续传
- 基准测试的结果发现rsync < scp < ssh < nc
    - 仅作参考
- **md5sum**
    - 校验文件的完整性
    - 完整扫描的代价比较高，压缩算法本身会做至少一次CRC检验

#### Chapter1
- **事务**
    - 一组原子性的SQL查询，即一个独立的工作单元，**由存储引擎实现，不在数据库服务层**
    - 要么全成功，要么全失败
    - **特性**
        - 原子性
        - 一致性 - *状态转换后保持一致*
        - 隔离性
        - 持久性
    - (需要数据库系统做更多的工作，增加了系统的开销)
    - **隔离级别**
        - 未提交读 - **脏读**，未提交的事务对其他事务是可见的
        - 提交读 - 未提交的事务对其他事务是不可见的
            - 不可重复读，同一事务中执行相同的查询可能得到不同的结果
        - 可重复读(MySQL默认隔离级别)
            - **幻读**，事务前后两次读取范围记录时，会产生幻行，读取间隔另一个事务在该范围内插入了新纪录
            - 多版本并发控制可以解决幻读问题
        - 串行化 - 每一行数据加锁，导致大量的超时和锁争用问题
    - InnoDB可以在事务执行过程中的任何时候加锁，只能在COMMIT或ROLLBACK时才会释放所有的锁
        - *LOCK TABLES/UNLOCK TABLES*在服务器层实现
    - 死锁
        - 死锁检测和死锁超时机制
        - InnoDB，将持有最少行级排他锁的事务回滚(比较简单的**死锁回滚算法**)
        - 事务型系统只有部分或完全*回滚*其中一个事务，才能打破死锁，然后重新执行回滚的事务
    - 事务型存储引擎
        - InnoDB
        - NDB Cluster
- **多版本并发控制**
    - 基于提升并发性能的目标，事务型引擎不是简单地使用行级锁，同时实现了多版本并发控制机制
    - InnoDB-MVCC
        - 每行记录保存2个隐藏的列(空间->时间)，1列保存行记录的创建时间，1列保存行记录的删除时间
        - (“创建时间”、“删除时间”可能不是实际的时间，而是系统版本号作为事务的版本号)
        - 插入，当前系统版本号作为创建时间
        - 删除，当前系统版本号作为删除时间
        - 更新，插入一条新纪录，当前系统版本号作为新行的创建时间，当前系统版本号作为原行的删除时间
        - **查询**，事务的版本号大于或等于行记录的创建版本，小于行的删除版本(或行的删除版本未定义)
    - 只在**提交读**和**可重复读**两个隔离级别下工作，使得大多数读操作都不需要加锁，并且保证读取到符合标准的记录行
- InnoDB
    - 事务型(Commit, Rollback)
    - 自动崩溃恢复
    - 支持数据和索引放在单独的文件中
    - MVCC支持高并发
    - 默认隔离级别-可重复读
    - 间隙锁消除幻行的影响
    - 基于聚簇索引建立，主键查询的性能很高
- MyISAM
    - 不支持事务和行级锁(使用**表锁**)
    - 不支持崩溃后安全恢复
    - 支持全文索引
    - 支持表压缩(对于*只读*的数据进行压缩，可以减少磁盘空间和*磁盘IO*)

#### Chapter5
- 索引基础
    - **由存储引擎实现，不在数据库服务层**
    - 若查询使用了索引，MySQL在索引上按值查找后返回所有包含该值的数据行
    - **索引列**的顺序很重要，MySQL只能高效的使用索引的**最左前缀树**
    - (ORM在多数情况下能够产生符合逻辑、合法的查询，却不一定能产生高效的使用索引的查询)
- 类型
    - B Tree，InnoDB使用的是B+Tree，NDB使用的是T Tree
        - MYISAM根据数据的物理位置引用被索引的行，**InnoDB根据主键引用被索引的行**
        - 适用于**全键值、键值范围、或键前缀(最左前缀)查询**
        - 节点是有序组织的，除了按值查找，索引可以用于查询中的**ORDER BY**操作，只要ORDER BY子句满足索引的查询要求
    - 哈希索引(*Memory引擎*、*NDB集群引擎*支持)
        - 存储索引键的哈希码，哈希表则保存指向数据的指针
        - **只有精确匹配索引列的查询才会生效**
    - 自定义哈希索引(伪哈希索引)
        - 针对很长的数据(如**url**)，计算并存储哈希码，并且在哈希列上创建索引
        - 查询时WHERE同时带上哈希码和数据值，防止哈希冲突
        - CRC32()适用于数据量不大的场合，数据量很大时应考虑实现返回整型的64bit哈希函数
            - SHA1()和MD5()是强校验，为了最大限度消除冲突，计算量大且返回字符串，不宜直接使用
            - ```CONV(RIGHT(MD5('https://www.baidu.com'), 16), 16, 10)```
            - **尽可能地使用MySQL内置的<u>函数和特性</u>**
    - 空间数据索引R Tree
        - 用作地理数据存储
    - 全文索引
        - 不是简单的WHERE条件匹配，类似于搜索引擎的功能
- 优点
    - 减少服务器扫描的数据量(先找索引，再找数据)
    - 避免排序和临时表(B Tree是二叉搜索树，数据是有序的 **ORDER BY, GROUP BY**)
    - 将随机IO变成顺序IO(减少IO次数)
- 高效地选择和使用索引
    - **索引列**不能是表达式的一部分，也不能是MySQL函数的参数
    - 对于**BLOB、TEXT**很长类型的列，MySQL必须使用**前缀索引**，不允许索引完整的列
        - 选择合适的前缀长度，保证较高的*索引选择性=COUNT(DISTINC Column) / COUNT(\*)*
        - 使得索引更小、更快
        - 但是，前缀索引无法做GROUP BY和ORDER BY，也无法做覆盖索引
    - EXPLAIN计划中出现索引合并**index_merge**，应该检查表结构和查询语句
        - **WHERE...AND**相交操作上应该建立多列索引
        - **WHERE...OR**可以优化为UNION ALL
        - **UNION ALL**可能消耗大量CPU和内存资源在缓存、排序和合并操作上，还可能影响查询的并发性
    - 合适的索引列顺序很重要
